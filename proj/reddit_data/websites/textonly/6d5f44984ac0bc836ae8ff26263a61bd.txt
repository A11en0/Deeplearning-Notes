Skip to content
zwischenzugs
Anatomy of a Linux DNS Lookup – Part I
zwischenzugs
Uncategorized
June 8, 2018
December 24, 2018
DNS lookups
Eventually I got fed up with this and decided to figure out how it all hangs together. I couldn’t find a complete guide for this anywhere online, and talking to colleagues they didn’t know of any (or really what happens in detail)
So I’m writing the guide myself.
Turns out there’s quite a bit in the phrase ‘Linux does a DNS lookup’…
Other posts in the series:
Anatomy of a Linux DNS Lookup – Part II
Anatomy of a Linux DNS Lookup – Part III
Anatomy of a Linux DNS Lookup – Part IV
Anatomy of a Linux DNS Lookup – Part V – Two Debug Nightmares
“How hard can it be?”
These posts are intended to break down how a program decides how it gets an IP address on a Linux host, and the components that can get involved.
vagrant landrush
It’s also a valuable illustration of how something so simple can get so very complex over time. I’ve looked at over a dozen different technologies and their archaeologies so far while trying to grok what’s going on.
automation code
Note that this is not a post on ‘how DNS works’.
1) There is no such thing as a ‘DNS Lookup’ call
This is NOT how it works
The first thing to grasp is that there is no single method of getting a DNS lookup done on Linux.
getaddrinfo
151.101.192.81
151.101.192.81
They both get the same result, so they must be doing the same thing, right?
root@linuxdns1:~# strace -e trace=open -f ping -c1 google.com
open("/etc/ld.so.cache", O_RDONLY|O_CLOEXEC) = 3
open("/lib/x86_64-linux-gnu/libcap.so.2", O_RDONLY|O_CLOEXEC) = 3
open("/lib/x86_64-linux-gnu/libc.so.6", O_RDONLY|O_CLOEXEC) = 3
open("/etc/resolv.conf", O_RDONLY|O_CLOEXEC) = 4
open("/etc/resolv.conf", O_RDONLY|O_CLOEXEC) = 4
open("/etc/nsswitch.conf", O_RDONLY|O_CLOEXEC) = 4
open("/etc/ld.so.cache", O_RDONLY|O_CLOEXEC) = 4
open("/lib/x86_64-linux-gnu/libnss_files.so.2", O_RDONLY|O_CLOEXEC) = 4
open("/etc/host.conf", O_RDONLY|O_CLOEXEC) = 4
open("/etc/ld.so.cache", O_RDONLY|O_CLOEXEC) = 4
open("/lib/x86_64-linux-gnu/libnss_dns.so.2", O_RDONLY|O_CLOEXEC) = 4
open("/lib/x86_64-linux-gnu/libresolv.so.2", O_RDONLY|O_CLOEXEC) = 4
PING google.com (216.58.204.46) 56(84) bytes of data.
64 bytes from lhr25s12-in-f14.1e100.net (216.58.204.46): icmp_seq=1 ttl=63 time=13.0 ms
$ strace -e trace=open -f host google.com
[...]
google.com has address 216.58.204.46
[...]
nsswitch.conf
/etc/resolv.conf
/etc/nsswitch.conf
/etc/nsswitch.conf
NSSwitch is not just for DNS lookups. It’s also used for passwords and user lookup information (for example).
NSSwitch was originally created as part of the Solaris OS to allow applications to not have to hard-code which file or service they look these things up on, but defer them to this other configurable centralised place they didn’t have to worry about.
nsswitch.conf
hosts: files dns myhostname
            
nsswitch.conf
nsswitch.conf
nsswitch.conf
hosts: files
$ ping -c1 google.com

ping: unknown host google.com
$ ping -c1 localhost

PING localhost (127.0.0.1) 56(84) bytes of data.

64 bytes from localhost (127.0.0.1): icmp_seq=1 ttl=64 time=0.039 ms
host google.com

google.com has address 216.58.206.110
nsswitch.conf
nsswitch.conf
nsswitch.conf
$ ping -c1 google.com

PING google.com (216.58.198.174) 56(84) bytes of data.

64 bytes from lhr25s10-in-f174.1e100.net (216.58.198.174): icmp_seq=1
$ ping -c1 localhost

ping: unknown host localhost
nsswitch.conf
/etc/resolv.conf
/etc/resolv.conf
/etc/resolv.conf
# Dynamic resolv.conf(5) file for glibc resolver(3) generated by resolvconf(8)
nameserver 10.0.2.3
Ignore the first two lines – we’ll come back to those (they are significant, but you’re not ready for that ball of wool yet).
If you hash out that line:
#nameserver 10.0.2.3
ping: unknown host google.com

it fails, because there’s no nameserver to go to (*).
resolv.conf
ping google
PING google.com (216.58.204.14) 56(84) bytes of data.
End of Part I
That’s the end of Part I. The next part will start by looking at how that resolv.conf gets created and updated.
Here’s what you covered above:
There’s no ‘DNS lookup’ call in the OS
/etc/resolv.conf
/etc/resolv.conf
which addresses get called
which DNS server to look up
If you thought that was complicated, buckle up…
Learn Git the Hard Way
Learn Terraform the Hard Way
Learn Bash the Hard Way
Or you might like 
Docker in Practice
Get 39% off Docker in Practice with the code: 39miell2
Share this:
Share on Tumblr
zwischenzugs

				View all posts by zwischenzugs			
June 8, 2018
December 24, 2018
Post navigation
Previous Post
Anatomy of a Linux DNS Lookup – Part I
Recommended Read: Anatomy of a Linux DNS Lookup – Part I | thechrisshort
Gordon Messmer

								June 9, 2018 at 5:08 pm							
This is a good write-up.  I think there are a couple of things you could add, because the POSIX DNS API is actually a little more complex than this, even.
(First, to pick a nit: What you’re describing has nothing to do with Linux.  The specification is POSIX, and the implementation is GNU.  All of this applies equally to GNU/Windows, aka WSL or “bash on Windows”, where there is no Linux component.)
GNU libc provides three different name resolution APIs.  There is the low-level DNS resolver library (RESOLVER(3)) which implements a BSD specification, there is gethostbyname (GETHOSTBYNAME(3)) and its related functions which implement an obsolete POSIX specification, and there is getaddrinfo (GETADDRINFO(3)) which is the modern POSIX API for name resolution.
Applications fall into one of maybe three categories.  Maybe two.  It’s subjective.  The first is older applications which still use the obsolete gethostbyname() API.  The second is newer applications that use getaddrinfo().  Both of those will go through the GNU libc NSS service, so they’ll parse /etc/nsswitch.conf, and from there they might use /etc/hosts, /etc/resolv.conf, /etc/hostname, and they might also use multicast DNS or an NSS caching service like nscd or sssd.  The getaddrinfo API will also consult /etc/gai.conf to order address results according to system preference.
The third group of applications (or second group, depending on your point of view) is applications that don’t use the POSIX NSS APIs at all.  This includes the “host” utility, because “host” is actually one of the applications included with ISC BIND, and it is intended specifically to interface with DNS directly, and not the system NSS API.  It also includes applications like Firefox which bypass NSS and implement their own DNS API for performance reasons.  And it includes applications which need access to records other than A and AAAA records.  Such applications will need to use the resolver library or their own DNS client library to access MX or TXT records.
I also want to note that “ping localhost” should not fail when nsswitch refers only to DNS.  A DNS server is required by RFC to resolve the name “localhost”.  The DNS service that you’re using is not compliant with standards, due to a configuration error.
And, finally, that the documentation for gethostbyname indicates that it will fall back to a DNS server on 127.0.0.1, just like ISC’s “host” application.  The documentation for getaddrinfo does not contain such a note, but I suspect that it will do the same since those are both part of GNU libc’s NSS API.
Thanks for the write-up.  I hope this helps.
zwischenzugs

								June 10, 2018 at 1:32 pm							
This ^^^ is absolute gold, thank you so much for posting it. I’ll work it in as I go. Some of it I knew but didn’t want to overwhelm the reader, but a lot of it I did not know at all.
Anatomy of a Linux DNS Lookup – Part II – zwischenzugs
Khurram Subhani

								June 19, 2018 at 2:52 pm							
maybe a silly question to ask: How does nsswitch.conf know what files or dns is/pointing to? Is there a config file which points ‘files’ to’/etc/hosts’. The reason why I am asking is that I saw above ‘myhostname’ as an option which points to /etc/hosts & /etc/hostnames
zwischenzugs

								June 19, 2018 at 3:08 pm							
It’s not a silly question, it’s just the kind of question I need to ask and answer to write these things.
zwischenzugs

								June 19, 2018 at 4:01 pm							
The man nsswitch.conf page suggests they’re hard-coded. You could get the source and examine it to be sure…

								June 22, 2018 at 8:25 pm							
that’s exactly the reason why I always use getent hosts example.org when shell scripting. it uses the c call, queries the system’s host database and honors nsswitch. the rabbit hole goes even deeper .I’ve seen a dozen of different output formats from host – a nightmare to parse but I won’t go into details
Anatomy of a Linux DNS Lookup – Part III – zwischenzugs
DNS lookup tutorial (1) | 0ddn1x: tricks with *nix
Links 10/7/2018: Wine 3.12, FreeNAS 11.2 Beta, GNU Helps Journalism | Techrights
Weekly DevOps News #1 - Codeogre
Anatomy of a Linux DNS Lookup – Part IV – zwischenzugs
Anatomy of a Linux DNS Lookup – Part V – Two Debug Nightmares – zwischenzugs
Bug Bytes #23 – 20K IDOR Trick, Bug Bounty Vloggers everywhere & Persistent Burp Collaborator – INTIGRITI

								December 1, 2019 at 5:15 pm							
You kind of already toughed on it with the host utility, but for extra points on how screwed up things are you could look at things that does not use the C standard library (libc). An “interesting” read is diving into how golang applications resolves things. The golang library tries to guess things about nss and fake it. A testcase to show how broken it is can for example be to install nss-myhostname and rm /etc/hosts … The nss module should allow you to resolve localhost and your hostname, but since golang lib doesn’t actually call into the libc and thus nss stack it doesn’t work. Run tcpdump and you’ll see the queries go to your (isp) dns resolver!
Cancel reply
Enter your comment here...
Fill in your details below or click an icon to log in:
(Address never made public)
Connecting to %s
Notify me of new comments via email.
Notify me of new posts via email.
Learn how your comment data is processed
Follow me on Twitter
Top Posts & Pages
The First Non-Bullshit Book About Culture I've Read
How (and Why) I Run My Own DNS Servers
Ten Things I Wish I'd Known About bash
Anatomy of a Linux DNS Lookup - Part I
Bash to Python Converter
Why Everyone Working in DevOps Should Read The Toyota Way
Ten Things I Wish I'd Known Before Using Jenkins Pipelines
'AWS vs K8s' is the new 'Windows vs Linux'
Ten Things I Wish I'd Known Before Using Vagrant
Anatomy of a Linux DNS Lookup - Part II
Recent Posts
The First Non-Bullshit Book About Culture I’ve Read
Why Everyone Working in DevOps Should Read The Toyota Way
Surgically Busting the Docker Cache
Software Security Field Guide for the Bewildered
The Lazy Person’s Guide to the Info Command
A Hot Take on GitHub Actions
Seven God-Like Bash History Shortcuts You Will Actually Use
How Long Will It Take For The Leavers To Leave?
Goodbye Docker: Purging is Such Sweet Sorrow
Seven Surprising Bash Variables
The Missing Readline Primer
Apple’s HQ, Ruskin, Gothic Architecture, and Agile
Eight Obscure Bash Options You Might Want to Know About
‘AWS vs K8s’ is the new ‘Windows vs Linux’
Pranking the Bash Binary
Bash Startup Explained
Git Hooks the Hard Way
Notes on Books Read in 2018
Six Ways to Level Up Your nmap Game
Five Things I Wish I’d Known About Git
Eleven bash Tips You Might Want to Know
Learn Bash Debugging Techniques the Hard Way
Why Are Enterprises So Slow?
Anatomy of a Linux DNS Lookup – Part V – Two Debug Nightmares
Anatomy of a Linux DNS Lookup – Part IV
Anatomy of a Linux DNS Lookup – Part III
Anatomy of a Linux DNS Lookup – Part II
Anatomy of a Linux DNS Lookup – Part I
A Docker Image in Less Than 1000 Bytes
Autotrace – Debug on Steroids
Beyond ‘Punk Rock Git’ in Eleven Steps
Sandboxing Docker with Google’s gVisor
Unprivileged Docker Builds – A Proof of Concept
Learn Git Rebase Interactively
Terminal Perf Graphs in one Command
git log – the Good Parts
Five Key Git Concepts Explained the Hard Way
Create Your Own Git Diagrams
Five Things I Did to Change a Team’s Culture
Centralise Your Bash History
How (and Why) I Run My Own DNS Servers
Ten More Things I Wish I'd Known About bash
Download a Free Sample of Learn Bash the Hard Way
Ten Things I Wish I’d Known About bash
Project Management as Code with Graphviz
How to Manually Clear Locks in Jenkins
How I Manage My Time
Ten Things I Wish I’d Known About Chef
Vagrant and Ohai / Chef IP Address Hack
‘Towards a National Computer Grid’ – Electronic Computers, 1965
A Complete Chef Infrastructure on Your Laptop
Ten Things I Wish I’d Known Before Using Vagrant
A Checklist for Docker in the Enterprise (Updated)
OpenShift 3.6 DNS In Pictures
Puppeteer – Headless Chrome in a Container
My 20-Year Experience of Software Development Methodologies
A Non-Cloud Serverless Application Pattern Using Git and Docker
Run Your Own AWS APIs on OpenShift
Dockerized Headless Chrome Example
Convert a Server to a Docker Container (Update II)
Automating Dockerized Jenkins Upgrades
Ten Things I Wish I’d Known Before Using Jenkins Pipelines
Five Books I Advise Every DevOps Engineer to Read
Things I Learned Managing Site Reliability for Some of the World’s Busiest Gambling Sites
Clustered VM Testing How-To
Easy Shell Automation
1-Minute Multi-Node VM Setup
Migrating an OpenShift etcd Cluster
A Complete OpenShift Cluster on Vagrant, Step by Step
Learn Kubernetes the Hard Way (the Easy and Cheap Way)
Docker in the Enterprise
Terraform and Dynamic Environments
Bash to Python Converter
Hello world Unikernel Walkthrough
A checklist for Docker in the Enterprise
A Quick Tour of Docker 1.12
Power ‘git log’ graphing
ssh -R (reverse tunnel) man page hell
Writing a Technical Book
Interactive Git Tutorials – Rebase and Bisect
Hitler Uses Docker, Annotated
Linux Scales
Play With Kubernetes Quickly Using Docker (Updated)
Convert Any Server to a Docker Container (Updated)
CI as Code Part III: Dynamic Jenkins-Swarm Example
Docker 1.10 Highlights – Updated
CI as Code Part II: Stateless Jenkins With Dynamic Docker Slaves
CI as Code Part I: Stateless Jenkins Deployments Using Docker
Docker Ecosystem Rosetta Stones
Understanding Docker – A Tour of Logical Volume Management
Automating Docker Security Validation
The IT Crowd Was Right – What I learned by reading a lot of RFCs
Understanding Docker – Network Namespaces
DockerConEU 2015 Talk – You Know More Than You Think
Docker Migration In-Flight CRIU
A High Availability Phoenix and A/B Deployment Framework using Docker
Quick Intro to Kubernetes
Take OpenShift for a spin in four commands
RedHat's Docker Build Method – S2I
RedHat’s Docker Build Method – S2I
Bash Shortcuts Gem
A CoreOS Cluster in Two Minutes With Four Commands
The Most Pointless Docker Command Ever
My Favourite Docker Tip
Convert Any Server to a Docker Container
A Field Guide to Docker Security Measures
Docker SELinux Experimentation with Reduced Pain
Storage Drivers and Docker
Play With Kubernetes Quickly Using Docker
Play with an OpenShift PaaS using Docker
Scale Your Jenkins Compute With Your Dev Team: Use Docker and Jenkins Swarm
Docker in Practice – A Guide for Engineers
Fight Docker Package Drift!
Win at 2048  with Docker and ShutIt (Redux)
Set Up a Deis (Docker-Friendly) Paas on Digital Ocean for $0.18 Per Hour in Six Easy Steps Using ShutIt
Create your own CoreOS cluster in 6 easy steps for $0.03
Make Your Own Bespoke Docker Image
Taming Slaves with Docker and ShutIt
Docker – One Year On
Using ShutIt to Build Your Own Taiga Server
Using ShutIt and Docker to play with AWS (Part Two)
Talk on Docker and ShutIt
Using ShutIt and Docker to play with AWS (Part One)
Phoenix deployment pain (and win)
Phoenix Deployment with Docker and ShutIt
Docker, ShutIt and the Perfect 2048 Game (Videos)
Docker, ShutIt and the Perfect 2048 Game (4 – Halfway There)
Docker, ShutIt and the Perfect 2048 Game (3 – Brute Force Escapes)
Docker, ShutIt and the Perfect 2048 Game (2)
Docker, ShutIt, and The Perfect 2048 Game
My Favourite Secret Weapon – strace
Shakespeare’s Vocabulary Considered Unexceptional
Follow zwischenzugs on WordPress.com
WordPress.com
Send to Email Address
Your Email Address

				Post was not sent - check your email addresses!			

				Email check failed, please try again			

				Sorry, your blog cannot share posts by email.			